import time

import numpy as np

from geometry_tools import representation, utils
from geometry_tools.automata import fsa

# "symmetric" is a local module which we use for some symmetric space
# computation
import symmetric

# ensures that we will not try and create ndarrays with more than 1000
# * 1000 points in them
ARR_SIZE_CAP = 1000

# define the representation. This is a Hitchin rep in the Fuchsian
# locus.
t = 2*np.arccosh(1/np.tan(np.pi/8))
c = np.cosh(t)
s = np.sinh(t)

angle = np.pi / 4

rotation = np.array([
    [np.cos(angle), np.sin(angle), 0],
    [-np.sin(angle), np.cos(angle), 0],
    [0, 0, 1]
])

loxodromic = np.array([[c,0,s],[0,1,0],[s,0,c]])

rep = representation.Representation()
# define r and a; the other generators are conjugates of a by powers of r
rep["a"] = loxodromic
rep["r"] = rotation

rep["b"] = rep["raR"]
rep["c"] = rep["rraRR"]
rep["d"] = rep["rrraRRR"]

# define zetas used for zeta angles
zeta = np.diag(np.array([2,-1,-1]));
i_zeta = np.diag(np.array([1,1,-2]));

# load the automaton file (generated by kbmag)
automaton = fsa.load_kbmag_file("surface_automaton.wa")

# we will run the check on words of length 8 (= 4*2)
length = 4

# dictionaries to hold memoized computations as we explore the
# automaton
pre_memos = {}
post_memos = {}

# initial worst angles/spacing
worst_cos_z_angle = 1.0
worst_cos_iz_angle = 1.0
worst_dist = 1e20 # this should be ~infinity

starttime = time.time()

for vertex in automaton.vertices():
    # for each vertex v of the automaton:
    # 1. get an array of elements of length l coming from paths ending at v
    # 2. get an array of elements of length l coming from paths starting at v

    # we need to compute inverses of prefixes, so also get the list of words in the (abstract) generators
    prefix, prefix_words = rep.automaton_accepted(automaton, length, end_state=vertex,
                                    maxlen=False, precomputed=pre_memos, with_words=True)

    # no need to compute inverses for postfixes so just get the matrices
    postfix = rep.automaton_accepted(automaton, length, start_state=vertex,
                                      maxlen=False, precomputed=post_memos)

    if len(prefix) == 0 or len(postfix) == 0:
        continue

    # cut up the prefix and postfix lists into fixed-length chunks,
    # and run the straight-and-spaced check on them
    n = len(prefix)
    m = len(postfix)
    n_segments = int(n / ARR_SIZE_CAP) + 1
    m_segments = int(m / ARR_SIZE_CAP) + 1
    for i in range(n_segments):
        for j in range(m_segments):

            # find the formal inverse of prefix words, and then compute matrices
            prefix_chunk_words = np.array(prefix_words)[i * ARR_SIZE_CAP:min((i + 1) * ARR_SIZE_CAP, n)]
            prefix_elts = rep.elements([
                utils.words.formal_inverse(word) for word in prefix_chunk_words
            ])

            postfix_elts = postfix[j * ARR_SIZE_CAP:min((j + 1) * ARR_SIZE_CAP, m)]

            # compute points in the symmetric space coming from the prefix/postfix isometries,
            # as well as the midpoints on the geodesics from these points to the origin.
            p1 = symmetric.SymmetricPoint.from_translation(prefix_elts)
            p2 = symmetric.SymmetricPoint.from_translation(postfix_elts)

            m1 = p1.origin_midpoint()
            m2 = p2.origin_midpoint()

            # filter out points where an eigenvalue is zero since they cause numerical issues / crashes
            m1_nonzero = np.all(m1.a != 0.0, axis=-1)
            m2_nonzero = np.all(m2.a != 0.0, axis=-1)
            m1 = m1[m1_nonzero]
            m2 = m2[m2_nonzero]

            # also compute the "backwards" midpoints coming from the extended geodesic segments
            m1_inv = m1.invert_by_transvection()
            m2_inv = m2.invert_by_transvection()

            # to compute relevant angles, we need to translate one of our midpoints to
            # the origin and see where the other one ends up
            m1_inv_m2 = symmetric.apply_isometry(m1.to_origin(), m2,
                                                 broadcast="pairwise_reversed")
            m2_inv_m1 = symmetric.apply_isometry(m2.to_origin(), m1,
                                                 broadcast="pairwise_reversed")

            # compute distances and zeta-angles
            dists = m1_inv_m2.distance_to_origin()
            cos_z_angle = symmetric.cos_zeta_angle_from_origin(m2_inv, m2_inv_m1, zeta,
                                             broadcast="elementwise")
            cos_iz_angle = symmetric.cos_zeta_angle_from_origin(m1_inv, m1_inv_m2, i_zeta,
                                                  broadcast="elementwise")

            worst_dist = min(worst_dist, np.min(dists))
            worst_cos_z_angle = min(worst_cos_z_angle, np.min(cos_z_angle))
            worst_cos_iz_angle = min(worst_cos_iz_angle, np.min(cos_iz_angle))

            print(
                "vertex: {} / {}, chunk {} / {} ({} group elements)".format(
                    vertex, len(automaton.vertices()),
                    i * m_segments + j + 1, n_segments * m_segments,
                    len(prefix_elts) * len(postfix_elts)
            ))

timedelta = time.time() - starttime
print(f"Complete, time was {timedelta} seconds.")
print(f"Worst spacing: {worst_dist}")
print(f"Worst cos_z_angle: {worst_cos_z_angle}")
print(f"Worst cos_iz_angle: {worst_cos_iz_angle}")
